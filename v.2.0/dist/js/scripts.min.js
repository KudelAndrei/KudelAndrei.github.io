/*!
 * Waves v0.6.4
 * http://fian.my.id/Waves
 *
 * Copyright 2014 Alfiana E. Sibuea and other contributors
 * Released under the MIT license
 * https://github.com/fians/Waves/blob/master/LICENSE
 */

;(function(window) {
    'use strict';

    var Waves = Waves || {};
    var $$ = document.querySelectorAll.bind(document);

    // Find exact position of element
    function isWindow(obj) {
        return obj !== null && obj === obj.window;
    }

    function getWindow(elem) {
        return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    function offset(elem) {
        var docElem, win,
            box = {top: 0, left: 0},
            doc = elem && elem.ownerDocument;

        docElem = doc.documentElement;

        if (typeof elem.getBoundingClientRect !== typeof undefined) {
            box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
        };
    }

    function convertStyle(obj) {
        var style = '';

        for (var a in obj) {
            if (obj.hasOwnProperty(a)) {
                style += (a + ':' + obj[a] + ';');
            }
        }

        return style;
    }

    var Effect = {

        // Effect delay
        duration: 750,

        show: function(e, element) {

            // Disable right click
            if (e.button === 2) {
                return false;
            }

            var el = element || this;

            // Create ripple
            var ripple = document.createElement('div');
            ripple.className = 'waves-ripple';
            el.appendChild(ripple);

            // Get click coordinate and element witdh
            var pos         = offset(el);
            var relativeY   = (e.pageY - pos.top);
            var relativeX   = (e.pageX - pos.left);
            var scale       = 'scale('+((el.clientWidth / 100) * 10)+')';

            // Support for touch devices
            if ('touches' in e) {
              relativeY   = (e.touches[0].pageY - pos.top);
              relativeX   = (e.touches[0].pageX - pos.left);
            }

            // Attach data to element
            ripple.setAttribute('data-hold', Date.now());
            ripple.setAttribute('data-scale', scale);
            ripple.setAttribute('data-x', relativeX);
            ripple.setAttribute('data-y', relativeY);

            // Set ripple position
            var rippleStyle = {
                'top': relativeY+'px',
                'left': relativeX+'px'
            };

            ripple.className = ripple.className + ' waves-notransition';
            ripple.setAttribute('style', convertStyle(rippleStyle));
            ripple.className = ripple.className.replace('waves-notransition', '');

            // Scale the ripple
            rippleStyle['-webkit-transform'] = scale;
            rippleStyle['-moz-transform'] = scale;
            rippleStyle['-ms-transform'] = scale;
            rippleStyle['-o-transform'] = scale;
            rippleStyle.transform = scale;
            rippleStyle.opacity   = '1';

            rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
            rippleStyle['-moz-transition-duration']    = Effect.duration + 'ms';
            rippleStyle['-o-transition-duration']      = Effect.duration + 'ms';
            rippleStyle['transition-duration']         = Effect.duration + 'ms';

            rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['-moz-transition-timing-function']    = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['-o-transition-timing-function']      = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
            rippleStyle['transition-timing-function']         = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';

            ripple.setAttribute('style', convertStyle(rippleStyle));
        },

        hide: function(e) {
            TouchHandler.touchup(e);

            var el = this;
            var width = el.clientWidth * 1.4;

            // Get first ripple
            var ripple = null;
            var ripples = el.getElementsByClassName('waves-ripple');
            if (ripples.length > 0) {
                ripple = ripples[ripples.length - 1];
            } else {
                return false;
            }

            var relativeX   = ripple.getAttribute('data-x');
            var relativeY   = ripple.getAttribute('data-y');
            var scale       = ripple.getAttribute('data-scale');

            // Get delay beetween mousedown and mouse leave
            var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
            var delay = 350 - diff;

            if (delay < 0) {
                delay = 0;
            }

            // Fade out ripple after delay
            setTimeout(function() {
                var style = {
                    'top': relativeY+'px',
                    'left': relativeX+'px',
                    'opacity': '0',

                    // Duration
                    '-webkit-transition-duration': Effect.duration + 'ms',
                    '-moz-transition-duration': Effect.duration + 'ms',
                    '-o-transition-duration': Effect.duration + 'ms',
                    'transition-duration': Effect.duration + 'ms',
                    '-webkit-transform': scale,
                    '-moz-transform': scale,
                    '-ms-transform': scale,
                    '-o-transform': scale,
                    'transform': scale,
                };

                ripple.setAttribute('style', convertStyle(style));

                setTimeout(function() {
                    try {
                        el.removeChild(ripple);
                    } catch(e) {
                        return false;
                    }
                }, Effect.duration);
            }, delay);
        },

        // Little hack to make <input> can perform waves effect
        wrapInput: function(elements) {
            for (var a = 0; a < elements.length; a++) {
                var el = elements[a];

                if (el.tagName.toLowerCase() === 'input') {
                    var parent = el.parentNode;

                    // If input already have parent just pass through
                    if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {
                        continue;
                    }

                    // Put element class and style to the specified parent
                    var wrapper = document.createElement('i');
                    wrapper.className = el.className + ' waves-input-wrapper';

                    var elementStyle = el.getAttribute('style');

                    if (!elementStyle) {
                        elementStyle = '';
                    }

                    wrapper.setAttribute('style', elementStyle);

                    el.className = 'waves-button-input';
                    el.removeAttribute('style');

                    // Put element as child
                    parent.replaceChild(wrapper, el);
                    wrapper.appendChild(el);
                }
            }
        }
    };


    /**
     * Disable mousedown event for 500ms during and after touch
     */
    var TouchHandler = {
        /* uses an integer rather than bool so there's no issues with
         * needing to clear timeouts if another touch event occurred
         * within the 500ms. Cannot mouseup between touchstart and
         * touchend, nor in the 500ms after touchend. */
        touches: 0,
        allowEvent: function(e) {
            var allow = true;

            if (e.type === 'touchstart') {
                TouchHandler.touches += 1; //push
            } else if (e.type === 'touchend' || e.type === 'touchcancel') {
                setTimeout(function() {
                    if (TouchHandler.touches > 0) {
                        TouchHandler.touches -= 1; //pop after 500ms
                    }
                }, 500);
            } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {
                allow = false;
            }

            return allow;
        },
        touchup: function(e) {
            TouchHandler.allowEvent(e);
        }
    };


    /**
     * Delegated click handler for .waves-effect element.
     * returns null when .waves-effect element not in "click tree"
     */
    function getWavesEffectElement(e) {
        if (TouchHandler.allowEvent(e) === false) {
            return null;
        }

        var element = null;
        var target = e.target || e.srcElement;

        while (target.parentNode !== null) {
            if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {
                element = target;
                break;
            }
            target = target.parentNode;
        }
        return element;
    }

    /**
     * Bubble the click and show effect if .waves-effect elem was found
     */
    function showEffect(e) {
        var element = getWavesEffectElement(e);

        if (element !== null) {
            Effect.show(e, element);

            if ('ontouchstart' in window) {
                element.addEventListener('touchend', Effect.hide, false);
                element.addEventListener('touchcancel', Effect.hide, false);
            }

            element.addEventListener('mouseup', Effect.hide, false);
            element.addEventListener('mouseleave', Effect.hide, false);
            element.addEventListener('dragend', Effect.hide, false);
        }
    }

    Waves.displayEffect = function(options) {
        options = options || {};

        if ('duration' in options) {
            Effect.duration = options.duration;
        }

        //Wrap input inside <i> tag
        Effect.wrapInput($$('.waves-effect'));

        if ('ontouchstart' in window) {
            document.body.addEventListener('touchstart', showEffect, false);
        }

        document.body.addEventListener('mousedown', showEffect, false);
    };

    /**
     * Attach Waves to an input element (or any element which doesn't
     * bubble mouseup/mousedown events).
     *   Intended to be used with dynamically loaded forms/inputs, or
     * where the user doesn't want a delegated click handler.
     */
    Waves.attach = function(element) {
        //FUTURE: automatically add waves classes and allow users
        // to specify them with an options param? Eg. light/classic/button
        if (element.tagName.toLowerCase() === 'input') {
            Effect.wrapInput([element]);
            element = element.parentNode;
        }

        if ('ontouchstart' in window) {
            element.addEventListener('touchstart', showEffect, false);
        }

        element.addEventListener('mousedown', showEffect, false);
    };

    window.Waves = Waves;

    document.addEventListener('DOMContentLoaded', function() {
        Waves.displayEffect();
    }, false);

})(window);

window.onload=function(){function e(){window.scrollBy(0,-50),window.pageYOffset>0&&requestAnimationFrame(e)}function t(e){document.getElementById("loaders").classList.remove("hidden");for(var t=0;t<h.children.length;t++)h.children[t].classList.remove("active"),e.target.parentNode.getAttribute("data-link")==h.children[t].id&&(h.children[t].classList.add("active"),"works"==h.children[t].id&&(p.querySelector(".work__item").style="display: flex;"));setTimeout(function(){document.getElementById("loaders").classList.add("hidden")},300)}function n(e,t,n){var i=n?e.target.parentNode:e.target;e.preventDefault();for(var s=0;s<t.length;s++)t[s].classList.remove("active");i.classList.add("active")}function i(){y.open("GET",x,!0),y.setRequestHeader("Content-Type","application/json"),y.onreadystatechange=function(){if(4==y.readyState&&200==y.status){l(JSON.parse(y.response))}},y.send()}function s(){g.open("GET","../layout/filters-work.html",!0),g.setRequestHeader("Content-Type","application/html"),g.onreadystatechange=function(){if(4==g.readyState&&200==g.status){a(g.responseText),v.classList.add("scale-out"),setTimeout(function(){v.style="display: none;"},200)}},g.send()}function a(e){document.getElementById("works").insertAdjacentHTML("afterBegin",e),o();var t=document.getElementById("work-filters"),i=t.getElementsByTagName("li"),s=document.getElementById("work-sort"),a=s.getElementsByTagName("li");t.addEventListener("click",function(){n(event,i)}),s.addEventListener("click",function(){n(event,a),"list"==document.querySelector("#work-sort .work__filter.active").dataset.sort?p.classList.add("list"):p.classList.remove("list")})}function l(e){var t="",n=e.length;q=n-T<2?n-T:2;for(var i=T;i<T+q;i++){var s=p.firstChild.nextSibling.cloneNode(!0);s.classList.add(e[i].type),s.querySelector(".work__img img").src=e[i].img,s.querySelector(".work__type").innerHTML=e[i].type,s.querySelector(".work__date").innerHTML=e[i].date,s.querySelector(".work__head").innerHTML=e[i].head,s.querySelector(".work__desc").innerHTML=e[i].desc;for(var a=0;a<e[i].tag.length;a++){var l=s.querySelector(".work__tags"),o=l.querySelector(".work__tag");o.innerHTML=e[i].tag[a],l.appendChild(o)}s.querySelector(".work__author-img img").src=e[i].authorImg,s.querySelector(".work__author-name").innerHTML=e[i].authorName;var r=document.createElement("div");r.appendChild(s),t+=r.innerHTML,i==n-1&&L.classList.add("disabled")}T+=2,p.insertAdjacentHTML("beforeend",t);var d=document.querySelector(".work__filter.active");if(d)for(var i=0;i<p.children.length;i++)p.children[i].style="display: none;",p.children[i].classList.contains(d.dataset.filter)&&(p.children[i].style="display: flex;")}function o(){var e=document.getElementById("work-filters");e.addEventListener("click",function(){var t=event.target;if(e!=t)for(var n=0;n<p.children.length;n++)p.children[n].style="display: none;",p.children[n].classList.contains(t.dataset.filter)&&(p.children[n].style="display: flex;")})}function r(){this.classList.toggle("active"),d()}function d(){E.classList.contains("mobile")?(I.style="min-width: 100%; left: -300px;",w.classList.contains("active")?(_.style="left: 50%; transform: translateX(-50%);",B.style="left: 0; top: 0; border-radius: 0; opacity: .8; transform: scale(1);"):_.style="left: -600px; transform: translateX(0);"):(B.style="left: -100%;",w.classList.contains("active")?(_.style="left: 0px;",I.style="min-width: auto; left: 0;"):(_.style="left: -600px;",I.style="min-width: 100%; left: -300px;"))}function c(){window.innerWidth<680?(E.classList.add("mobile"),w.classList.remove("active")):(E.classList.remove("mobile"),w.classList.add("active"))}function m(){E.classList.contains("mobile")&&(_.style="left: -600px;",B.style="left: -100%;",w.classList.remove("active"),I.style="min-width: 100%; left: -300px;")}var u=document.getElementById("menu"),f=u.getElementsByTagName("li"),y=new XMLHttpRequest,g=new XMLHttpRequest,v=document.getElementById("btn-filters"),h=document.getElementById("content-info"),p=document.getElementById("works-container"),L=document.getElementById("work-ajax"),w=document.getElementById("toggle-menu"),E=document.getElementById("home"),k=document.getElementById("btn-top"),B=document.getElementById("home-before"),_=document.getElementById("aside"),I=document.getElementById("main"),T=0,q=0,x="../data/works.json";c(),d(),function(){u.firstElementChild.classList.add("active"),document.getElementById("about").classList.add("active"),setTimeout(function(){document.getElementById("loaders").classList.add("hidden")},300)}(),k.addEventListener("click",function(t){t.preventDefault(),e()},!1),u.addEventListener("click",function(){m(),n(event,f,!0),t(event)}),v.addEventListener("click",s),w.addEventListener("click",r),B.addEventListener("click",function(){m()}),L.addEventListener("click",i),window.onresize=function(){c(),d()},window.onscroll=function(){!function(){window.pageYOffset>=600?k.style="bottom: -35px; right: -35px;":k.style="bottom: -100px; right: -100px;"}()}};